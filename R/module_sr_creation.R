# ===========================================
# Custom Stressor-response creation function
# ===========================================

module_sr_creation_ui <- function(id) {
  ns <- NS(id)
  
  tagList(shinydashboard::box(width = 12, fluidRow(
    column(
      width = 12,
      
      tags$h3(
        "Formula Builder: Create Novel Stressors and Stressor-Response Relationships"
      ),
      
      tags$p(
        "The ‘Custom Stressor Creation’ module, within the ‘Special Features’ tab, can be used to develop novel stressors from existing data using a formula builder.",
        style = "text-align: justify;",
        class = "pm-ht"
      ),
      
      
      # Accordion container
      div(
        class = "panel-group",
        id = "accordion",
        # Accordion panel
        div(
          class = "panel panel-default",
          # Panel header (clickable)
          div(class = "panel-heading", h4(
            class = "panel-title",
            a(
              "Click to show full help dodumentation",
              `data-toggle` = "collapse",
              `data-parent` = "#accordion",
              href = "#collapseHelper"
            )
          )),
          # Collapsible panel body with the static helper text
          div(
            id = "collapseHelper",
            class = "panel-collapse collapse",
            div(
              class = "panel-body",
              
              tags$p(
                "The ‘Custom Stressor Creation’ module, within the ‘Special Features’ tab, can be used to develop novel stressors from existing data using a formula builder. The formula builder takes in existing variables, including existing stressors, and provides the option to add them into a custom formula expression input box to generate new variables. This module can be creatively leveraged for a myriad of applications. For example, the interaction between two stressors can be expressed and modelled as a new unique metrics, existing stressors can be re-computed for simple scenarios (e.g., adding 2 degrees to represent future climate change, or multiplying a land-use stressor by 0.8). The ‘Custom Stressor Creation’ module can also be used for more advanced applications such as applying preexisting regression equations to develop new stressors from specific input datasets where prior research has already developed detailed SR functions that are not expressed as simple univariate relationships.",
                style = "text-align: justify;",
                class = "pm-ht"
              ),
              
              
              tags$p(
                "There are several steps in the ‘Custom Stressor Creation’ module. First, a user adds selected variables (as stressors) into a formula builder input text box. Various mathematical expressions (e.g., addition, subtraction, multiplication, division, exponents, brackets, log, log10 etc.) can be used to customize the formula. Next, the user clicks the ‘Run Formula and Generate New Data’ button to apply the equation to all unique locations. A new temporary variable is generated and stored for each location that consists of the numerical result of the custom formula. The user carefully reviews the result of the equation to make an informed decision whether the new variable should be added to the model as a novel stressor. A stressor-response relationship is assigned to the new raw stressor values (either by copying values from a pre-existing stressor-response curve or developing a new custom stressor-response curve). Finally, the values are saved and added to the primary stressor magnitude and stressor-response datasets for use in the Joe Model and/or Population Model. Note that if the custom formula is treated as a stand-alone stressor response function, then the new raw stressor values generated by the function can be treated directly as the predicted habitat or system capacity, rather than treated as a stressor to which a stressor-response function is applied.  Alternatively, an identity stressor-response function (straight line with a slope of 1) can be chosen as the new custom stressor-response curve to treat the formula output as a direct metric of habitat capacity.",
                style = "text-align: justify;",
                class = "pm-ht"
              ),
              
            )
          )
        )
      ),
      
      
      
      
      
      shinydashboard::box(
        width = 12,
        # Create Bootstrap Pills of possible terms
        tags$b(
          "Possible Formula Terms (raw stressor variables to incorporate into equation):"
        ),
        
        div(textOutput(ns(
          "stressors_to_choose_from"
        )), style = "color: purple;"),
        
        
      ),
      
      
      tags$br(),
      
      
      
      
      
    )
  ), fluidRow(
    column(
      width = 12,
      fluidRow(
        column(
          width = 8,
          
          shinydashboard::box(
            width = 12,
            #style = "background-color: #dfebe8;",
            
            # '#dfebe8','#ffffb3','#dddaed','#ffd8d4'
            
            tags$h4("Step 1: Create a New Stressor with the Formula Builder"),
            
            tags$p(
              "Create a new stressor by entering a custom formula in the formula expression input textbox. Various mathmetrical expressions can be used such as addition (+), subtraction (-), multiplication (*), division (/), exponents(x^y), brackets((x)), log (e.g., log(x)), sqrt (e.g., sqrt(x)), log10 etc. Be careful to ensure that your formula is valid (e.g., has matching closing brackets). The only variables that can be used are the names of preexisting stressors in the stressor magnitude input workbook. Make sure the spelling is exact. Add custom metrics to the stressor magnitude data as needed. You do not need to define a stressor-response relationship for various habitat metrics that may exist only in the stressor-magnitude workbook. The following examples provide some sample formulas to help develop an understanding of the format and possibilities:",
              style = "text-align: justify;",
              class = "pm-ht"
            ),
            
            # Accordion container
            div(
              class = "panel-group",
              id = "accordion2",
              # Accordion panel
              div(
                class = "panel panel-default",
                # Panel header (clickable)
                div(class = "panel-heading", h4(
                  class = "panel-title",
                  a(
                    "Click to show some examples",
                    `data-toggle` = "collapse",
                    `data-parent` = "#accordion2",
                    href = "#collapseHelper2"
                  )
                )),
                # Collapsible panel body with the static helper text
                div(
                  id = "collapseHelper2",
                  class = "panel-collapse collapse",
                  div(
                    class = "panel-body",
                    HTML(
                      '
    <ul class = "pm-ht">
            <li>e.g., apply a function to estimate the habitat capacity (N) of a target species (e.g., cutthroat trout) by taking the cumulative product of habitat unit area summaries (e.g., m2 of pool habitat in a stream) and estimates of the hypothetical max parr density per habitat unit type [e.g., 0.16 parr/m2]):
        <ul>
          <li>(stream_area_pool*0.16)+(stream_area_glide*0.04)+( stream_area_riffle*0.01)</li>
        </ul>
      </li>
      <li>e.g., apply a simple fixed increase or decrease in the raw value of a stressor (e.g., fines):
        <ul>
          <li>Fines_pct*0.8</li>
          <li>Fines_pct-10</li>
        </ul>
      </li>
      <li>e.g., define a possible interactive effect between stream temperature and peak flows (example from Wenger et al., 2011: PNAS):
        <ul>
          <li>(-0.59*Temp)+((-0.88*Temp)^2)+(-0.20*PeakFlows)</li>
        </ul>
      </li>
      <li>e.g., apply a custom regression equation to roughly predict MWAT (Maximum Weekly Average Stream Temperature) from basin-level GIS variables (Moore et al., 2013: Canadian Water Resources Journal):
        <ul>
          <li>7.91+(0.484*July_Temp)+(1.18*log10(Drainage_Area_km2+0.000001))+(-0.00306*Median_Elev_m)+(17.5*sqrt(Lake_Cover_pct/100))+(-9.43*sqrt(Glacier_Cover_pct/100))+(0.0529*(Reach_Gradient_pct/100))-(0.719*0.25)</li>
        </ul>
      </li>
    </ul>'
                    ),
                  )
                )
              )
            ),
            
            # Text area for formula input
            textAreaInput(
              ns("formula"),
              label = "Enter Formula Expression Here:",
              value = "",
              rows = 3,
              placeholder = "Enter your formula here..."
            ),
            # Optional: UI to insert allowed variable names from the dataframe
            uiOutput(ns("var_buttons")),
            
            fluidRow(
              column(
                width = 6,
                # Button to evaluate the formula
                actionButton(
                  ns("eval_formula"),
                  "Run Formula and Generate New Data",
                  icon = icon("play"),
                  class = "btn btn-success",
                  style = "color: white; width: 100%; height: 50px; font-size: large;"
                )
              ),
              column(
                width = 3,
                # Numeric Integer input for number of decimals
                numericInput(
                  ns("r_decimals"),
                  label = "Round to (n) Decimals",
                  value = 2,
                  min = 0,
                  max = 100
                )
                
              ),
              column(
                width = 3,
                # Select box with option for color ramp to go from red high blue low or blue high red low:
                selectInput(
                  ns("color_ramp"),
                  label = "Color Ramp Direction",
                  choices = c("Red High, Blue Low", "Blue High, Red Low"),
                  selected = "Red High, Blue Low"
                )
              ),
            ),
            
            
            # Output: Show result of evaluating the formula on the dataframe
            verbatimTextOutput(ns("formula_result"))
            
            
            
          ),
          
          
          
          
          
          
        ),
        column(
          width = 4,
          
          tags$b("Result of Formula Evaluation:"),
          
          # plot output
          plotOutput(ns("hist_plot")),
          
        )
      ),
      tags$hr(),
      
      
      fluidRow(
        column(
          width = 8,
          
          # create box
          shinydashboard::box(
            width = 12,
            #style = "background-color: #f7f7e6;",
            
            tags$h4("Step 2: Evaluate Stressor Values"),
            
            tags$p(
              "After the ‘Run Formula and Generate New Data’ button is pushed the new stressor values are temporarily cached for review. Summary statistics are shown on the right side of the display and an interactive choropleth map interface is included below. Reviewing values in these sections is useful to identify possible errors and issues. The formula can be edited and rerun. Each time the ‘Run Formula and Generate New Data’ button is pushed the stressor data is overwritten",
              class = "pm-ht"
            )
          ),
          
          # call the submodule module_sr_creation_map_ui here
          module_sr_creation_map_ui(ns("module_sr_creation_map")),
          
        ),
        column(
          width = 4,
          style = "padding-left: 0; margin-left: -10px;",
          shinydashboard::box(width = 12, #style = "background-color: #f7f7e6;",
                              fluidRow(
                                column(width = 12, tags$br(), # create a reactive UI dynamic list object for summary stats
                                       uiOutput(ns(
                                         "s_summary_stats"
                                       )), tags$br(),
                                       
                                       # create a download link to export data
                                       uiOutput(ns("download_btn"))
                                       
                                       )
                              ))
        ),
      ),
      
      
      
      tags$p(
        "Evaluate results carefully before moving on to the next section.",
        class = "pm-ht"
      ),
      
      
      
      tags$br(),
      
      fluidRow(column(
        width = 8,
        shinydashboard::box(
          width = 12,
          #style = "background-color: #dddaed;",
          # '#dfebe8','#ffffb3','#dddaed','#ffd8d4'
          
          tags$h4("Step 3: Define or Develop a Stressor-Response Relationship"),
          
          tags$p(
            "In Step 3 users assign or develop a stressor-response relationship to be associated with the newly created stressor metric. Users may either copy an existing stressor-response relationship or create a new relationship from scratch. Copying an existing relationship can be useful if the newly created stressor represents a scenario or variant of a pre-existing stressor. Creating a new stressor-response relationship can be useful if the newly created stressor requires an entirely new relationship.",
            class = "small-helper-text"
          ),
          
          # create a radio select button for create new SR relationship or copy existing
          radioButtons(
            ns("sr_radio"),
            "Create New or Copy Existing Stressor-Response Relationship:",
            c(
              "Create New Stressor-Response Relationship" = "new",
              "Copy Existing Stressor-Response Relationship" = "copy"
            ),
            selected = "new"
          ),
          tags$p(
            "If a novel stressor-response relationship is being created from scratch, use the following inputs to define how the stressor is linked to the focal species/system. The stressor-response relationship table will also need to be populated. Rows can be added or removed to adjust the complexity of the relationship.",
            class = "small-helper-text"
          ),
          fluidRow(
            column(
              width = 3,
              selectInput(
                ns("s_Interaction"),
                "Interactions:",
                c("NA" = NA, "Minimum" = "Minimum")
              ),
              bsTooltip(
                id = ns("s_Interaction"),
                title = "Is the stressor part of a group of highly correlated stressors (e.g., road density, stream crossing density etc.)? If so, then choose Minimum (or Maximum) and assign the group for the stressor in the Interaction input. When stressors are grouped with Interaction/Linked groups, then only the stressor with the lowest (or highest) response score will be included in the final Joe Model run. This helps limit biases and stressors that are not independent of each other.",
                placement = "top",
                trigger = "hover"
              ),
              
              class = "grouped-box-1"
            ),
            column(
              width = 3,
              textInput(ns("s_Linked"), "Interaction (Linked) Groups:", value = NA),
              bsTooltip(
                id = ns("s_Linked"),
                title = "Defaults to NULL or NA. However, if the stressor is linked to other stressors as part of a group (previous input), then assign the name of the group here. For example, if Road Density and Stream Crossing Density are assigned the ‘Minimum’ interaction as part of a linked group then the linked group name could be ‘roads’. Make sure all stressors in the group share the same interaction input (e.g., Minimum) and the same linked group name. Do not use spaces or special characters in the linked group name.",
                placement = "top",
                trigger = "hover"
              ),
              class = "grouped-box-1"
            ),
            
            column(
              width = 3,
              selectInput(
                ns("s_Function"),
                "Function Type:",
                c("continuous" = "continuous", "step" = "step")
              ),
              bsTooltip(
                id = ns("s_Function"),
                title = "Define the function type of the stressor-response curve as either ‘continuous’ or ‘step’. Continuous functions are generally used where the stressor-response curve represents an underlying function with continuous data. For example, stream temperature and survivorship would generally be considered as ‘continuous’. Use ‘step’ if the stressor-response relationship represents discrete values (e.g., count of downstream barriers and passibility) or where the raw stressor data is based on discrete levels.",
                placement = "top",
                trigger = "hover"
              ),
              class = "grouped-box-2"
            ),
            
            column(
              width = 3,
              selectInput(
                ns("s_Stress_Scale"),
                "Raw Stressor Scale:",
                c("linear" = "linear", "log" = "log")
              ),
              bsTooltip(
                id = ns("s_Stress_Scale"),
                title = "Choose how interpolation should take place across the raw stressor values. Options include ‘linear’ (for linear interpolation, default) or ‘log’ (natural logarithm).",
                placement = "top",
                trigger = "hover"
              ),
              class = "grouped-box-2"
            )
          ),
          
          fluidRow(
            column(
              width = 3,
              selectInput(
                ns("s_Model"),
                "Model Endpoint:",
                c(
                  "All" = "All",
                  "Joe Model" = "Joe Model",
                  "Population Model" = "Population Model"
                )
              ),
              bsTooltip(
                id = ns("s_Model"),
                title = "What is the target model endpoint for the stressor and stressor-response function? Defaults to ‘All’, but options include ‘All’, ‘Joe Model’, or ‘Population Model’.",
                placement = "top",
                trigger = "hover"
              ),
              class = "grouped-box-4"
            ),
            column(
              width = 3,
              textInput(ns("s_Life_stages"), "Life Stages (Pop. Only):", value = NA),
              bsTooltip(
                id = ns("s_Life_stages"),
                title = "If the stressor-response function is being incorporated into the life cycle model (population model), then define the life stage linkage here. See the online guidance document (7. Life Cycle Model for a list of options, e.g., SE, S0, surv_1, eps_4, etc.). Can be left blank if using the Joe Model.",
                placement = "top",
                trigger = "hover"
              ),
              class = "grouped-box-3"
            ),
            column(
              width = 3,
              selectInput(
                ns("s_Parameters"),
                "Vital Rate Parameters (Pop. Only):",
                c(
                  "survival" = "survival",
                  "capacity" = "capacity",
                  "fecundity" = "fecundity"
                )
              ),
              bsTooltip(
                id = ns("s_Parameters"),
                title = "If the stressor-response function is being incorporated into the life cycle model (population model), and is linked to a life stage, define the vital rate parameter that is being modified. Options include ‘survival’, ‘capacity’, or ‘fecundity’. Recall the stressor-response functions act as rate modifiers.",
                placement = "top",
                trigger = "hover"
              ),
              class = "grouped-box-3"
            ),
            column(
              width = 3,
              textInput(ns("s_Units"), "Raw Stressor Units:", value = "units"),
              bsTooltip(
                id = ns("s_Units"),
                title = "(Optional, but recommended) Provide a specific name for the units of the raw stressor for reference (e.g., if the stressor is mean August Stream Temperature then the units are likely to be Celsius).",
                placement = "top",
                trigger = "hover"
              ),
              class = "grouped-box-4"
            )
          ),
          
          tags$br(),
          
          
          tags$b("Build the Stressor-Response Relationship"),
          
          tags$p(
            "Populate the following table with the raw stessor values (e.g., stream temperature in degrees), the stressor-response relationship score for each level (scaled from 0 to 100%), the standard deviation (SD) of the response for each part of the relationship (in percent), and the lower and upper limits of the response score (both scale from 0% to 100%).",
            class = "small-helper-text"
          ),
          
          
          
          # create a static html table with three rows and columns for 'Raw Stressor Value', 'Stressor-Response Score', 'SD', 'Lower Limit', 'Upper Limit'
          actionButton(ns("add_row"), "Add Row"),
          actionButton(ns("delete_row"), "Delete Row"),
          rHandsontableOutput(ns("hot")),
          
          # create a static html table with three rows and columns for 'Raw Stressor Value', 'Stressor-Response Score', 'SD', 'Lower Limit', 'Upper Limit'
          
        )
        
      ), column(width = 4, 
                
                # Create Stressor-Response Preview Plot Here:
                dygraphOutput(ns("sr_preview_plot"))
                
                )), tags$br(), 
      
      
      fluidRow(
        shinydashboard::box(
          width = 12,
          #style = "background-color: #ffd8d4;",
          
          # '#dfebe8','#ffffb3','#dddaed','#ffd8d4'
          
          tags$h4(
            "Step 4: Add New Stressor and Stressor-Response Relationship to Model"
          ),
          
          tags$p(
            "Finally, in Step 4, we take our newly created stressor and stressor-response relationship and add it to the stressor-magnitude and stressor-response datasets for use in the Joe and Population Model, as well as other components of the tool. After the ‘Add Stressor and Stressor-Response Relationship to Model’ button is pressed the entire application will update itself to include the newly created stressor. It is important to assign a clear and unique name to the new stressor. Do not use spaces or special characters.",
            class = "pm-ht"
          ),
          
          # Create an input text box for the user to enter a name for the new stressor
          textInput(ns("s_New_Stressor_Name"), "New Stressor Name:", value = "New_Stressor"),
          
          # create a green submit button
          actionButton(
            ns("save_data"),
            "Add Stressor and Stressor-Response Relationship to Model",
            class = "btn btn-success",
            icon = icon("save"),
            style = "color: white;"
          )
          
          
        )
      ),
      
      
      
    )
  )))
}


# ==========================
# SERVER FUNCTION
# ==========================

module_sr_creation_server <- function(id, df, allowed_vars = NULL) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    # Create placeholder reactive dataframe for the formula evaluation
    rv_formula_df <- reactiveValues(dat = NULL)
    
    # SHow list of stressors to choose from
    output$stressors_to_choose_from <- renderText({
      print("building stressors_to_choose_from...")
      stcf <- unique(session$userData$rv_stressor_magnitude$sm_dat$Stressor)
      stcf <- stcf[!(is.na(stcf) | stcf == "")]
      stcf <- sort(stcf)
      stcf <- paste(stcf, collapse = ", ")
      # browser()
      stcf
    })
    
    # ======================================================
    # Call the submodule and pass the reactive values
    # ======================================================
    
    module_sr_creation_map_server("module_sr_creation_map",
                                  rv_formula_df,
                                  reactive(input$color_ramp))
    
    # If a list of allowed variable names is provided, create a small insert widget.
    output$var_buttons <- renderUI({
      if (is.null(allowed_vars))
        return(NULL)
      tagList(
        selectInput(ns("var_select"), "Insert Variable:", choices = allowed_vars),
        actionButton(ns("insert_var"), "Insert")
      )
    })
    
    # When the "Insert" button is clicked, append the selected variable name to the formula.
    observeEvent(input$insert_var, {
      var_to_insert <- input$var_select
      new_formula <- paste0(input$formula, " ", var_to_insert)
      updateTextAreaInput(session, "formula", value = new_formula)
    })
    
    
    # A basic sanitization function that allows only common arithmetic characters,
    # letters, digits, whitespace, period, comma, and underscore.
    sanitize_formula_old <- function(formula_str) {
      # Allow letters, digits, whitespace, and these symbols: + - * / ^ ( ) . , _
      if (grepl("[^0-9a-zA-Z\\+\\-\\*/\\^\\(\\)\\.\\s,_]",
                formula_str)) {
        return(NULL)
      }
      return(formula_str)
    }
    
    sanitize_formula_new <- function(formula_str) {
      # Allow letters, digits, whitespace, and these symbols: + * / ^ ( ) . , _ and any punctuation dash
      if (grepl("[^0-9a-zA-Z\\+\\*/\\^\\(\\)\\.\\s,_\\p{Pd}]",
                formula_str,
                perl = TRUE)) {
        return(NULL)
      }
      return(formula_str)
    }
    
    
    
    # ----------------------------------------------------------------------
    # When "Evaluate Formula" is clicked, parse and evaluate the expression
    # ----------------------------------------------------------------------
    observeEvent(input$eval_formula, {
      formula_str <- input$formula
      
      # formula_str <- "log(1.3* (Fines/(8.1*Fry_Capacity))^2)"
      # formula_str <- "1.3*(Ficnes/(8.1*Fry_Capacity))^2"
      # print("Check this...")
      # browser()
      
      formula_str <- gsub(" ", "", formula_str)
      
      safe_formula <- sanitize_formula_new(formula_str)
      
      smd <- session$userData$rv_stressor_magnitude$sm_dat
      smd <- smd[, c("HUC_ID", "NAME", "Stressor", "Mean")]
      # Convert smd from long to wide format but keep HUC_ID
      smd2 <- spread(smd, key = "Stressor", value = "Mean")
      
      if (is.null(safe_formula)) {
        output$formula_result <- renderText("Error: Formula contains invalid characters!")
        return()
      }
      
      return_message <- "Formula Evaluated Successfully"
      
      # Try to parse and evaluate the expression.
      # We evaluate in the environment of the provided dataframe `df`.
      result <- tryCatch({
        expr <- parse(text = safe_formula)
        # Because the columns in df are vectorized, the expression is computed for every row.
        eval(expr, envir = smd2)
      }, error = function(e) {
        return_message <- paste("Error in evaluating formula:", e$message)
        return(NULL)
      })
      
      smd_out <- smd2[, c("HUC_ID", "NAME")]
      
      if (length(result) > 0) {
        if (return_message == "Formula Evaluated Successfully") {
          smd_out$val <- result
        } else {
          smd_out$val <- NA
        }
      } else {
        return_message <- paste(
          "Error in evaluating formula. Use round brackets and * symbol for multiplication..."
        )
        smd_out$val <- NA
      }
      
      # browser()
      
      # Update reactive object
      rv_formula_df$dat <- smd_out
      
      
      output$formula_result <- renderPrint(return_message)
    })
    
    # --------------------------------------------------------------
    # Download formula data button for download_data
    # --------------------------------------------------------------
    
    output$download_btn <- renderUI({
      if (is.null(rv_formula_df$dat)) {
        return(NULL)  # Don't show the button if no data
      } else {
        downloadButton(ns("download_data"), "Download Data")
      }
    })
    
    output$download_data <- downloadHandler(
      filename = function() {
        "formula_data.xlsx"
      },
      content = function(file) {
        
        # Gather data
        mydata <- rv_formula_df$dat
        
        # Round to set decimals
        n_round <- isolate(input$r_decimals)
        
        mydata$val <- round(mydata$val, n_round)
        
        mydata$Stressor <- "Custom"
        mydata$Stressor_cat <- "Custom"
        mydata$Mean <- mydata$val
        mydata$SD <- 0
        mydata$Distribution <- "normal"
        mydata$Low_Limit <- mydata$val
        mydata$Up_Limit <- mydata$val
        mydata$Comments <- NA
        
        mydata <- mydata[, c("HUC_ID", "NAME", "Stressor", "Stressor_cat",
                             "Mean", "SD", "Distribution", "Low_Limit",
                             "Up_Limit", "Comments")]
        
        write_xlsx(mydata, path = file)
        
      }
    )
    
    
    # --------------------------------------------------------------
    # Summary Statistics
    # --------------------------------------------------------------
    
    # fill the uiOutput for s_summary_stats from rv_formula_df$dat$val
    output$s_summary_stats <- renderUI({
      print("building s_summary_stats...")
      req(rv_formula_df$dat$val)
      
      vals <- rv_formula_df$dat$val
      
      # Round to n decimals
      n_decimals <- input$r_decimals
      
      if (length(n_decimals) == 0) {
        n_decimals <- 0
      }
      if (is.na(n_decimals)) {
        n_decimals <- 0
      }
      
      vals <- round(vals, n_decimals)
      
      mmin <- min(vals, na.rm = TRUE)
      mmax <- max(vals, na.rm = TRUE)
      mmean <- mean(vals, na.rm = TRUE)
      mmedian <- median(vals, na.rm = TRUE)
      mstd <- sd(vals, na.rm = TRUE)
      msum <- sum(vals, na.rm = TRUE)
      
      # Calculate percentile breakpoints
      mpercentiles <- quantile(vals, probs = seq(0, 1, 0.1), na.rm = TRUE)
      mpercentiles <- round(mpercentiles, n_decimals)
      
      
      # Define the color vector (for P10-P90)
      i_colors <- c(
        '#3288bd',
        '#66c2a5',
        '#abdda4',
        '#e6f598',
        '#ffffbf',
        '#fee08b',
        '#fdae61',
        '#f46d43',
        '#d53e4f'
      )
      
      # Reverse colors if needed
      if (input$color_ramp == "Blue High, Red Low") {
        m_colors <- rev(i_colors)
      } else {
        m_colors <- i_colors
      }
      
      print(input$color_ramp)
      
      
      # Render a ui list of all stats
      tagList(
        tags$b("Summary Statistics From Formula Values:"),
        tags$ul(
          tags$li(paste("Min:", mmin)),
          tags$li(paste("Max:", mmax)),
          tags$li(paste("Mean:", round(
            mmean, n_decimals
          ))),
          tags$li(paste(
            "Median:", round(mmedian, n_decimals)
          )),
          tags$li(paste("Std Dev:", round(
            mstd, n_decimals
          ))),
          tags$br(),
          tags$li(tags$b(paste(
            "Sum of Values:", round(msum, n_decimals)
          ))),
        ),
        tags$br(),
        tags$b("Percentile Breakpoints From Formula Values:"),
        tags$ul(
          tags$li(
            tags$span(
              style = sprintf(
                "display:inline-block; width:12px; height:12px; background-color:%s; margin-right:5px;",
                m_colors[1]
              )
            ),
            paste("P10:", mpercentiles[2])
          ),
          tags$li(
            tags$span(
              style = sprintf(
                "display:inline-block; width:12px; height:12px; background-color:%s; margin-right:5px;",
                m_colors[2]
              )
            ),
            paste("P20:", mpercentiles[3])
          ),
          tags$li(
            tags$span(
              style = sprintf(
                "display:inline-block; width:12px; height:12px; background-color:%s; margin-right:5px;",
                m_colors[3]
              )
            ),
            paste("P30:", mpercentiles[4])
          ),
          tags$li(
            tags$span(
              style = sprintf(
                "display:inline-block; width:12px; height:12px; background-color:%s; margin-right:5px;",
                m_colors[4]
              )
            ),
            paste("P40:", mpercentiles[5])
          ),
          tags$li(
            tags$span(
              style = sprintf(
                "display:inline-block; width:12px; height:12px; background-color:%s; margin-right:5px;",
                m_colors[5]
              )
            ),
            paste("P50:", mpercentiles[6])
          ),
          tags$li(
            tags$span(
              style = sprintf(
                "display:inline-block; width:12px; height:12px; background-color:%s; margin-right:5px;",
                m_colors[6]
              )
            ),
            paste("P60:", mpercentiles[7])
          ),
          tags$li(
            tags$span(
              style = sprintf(
                "display:inline-block; width:12px; height:12px; background-color:%s; margin-right:5px;",
                m_colors[7]
              )
            ),
            paste("P70:", mpercentiles[8])
          ),
          tags$li(
            tags$span(
              style = sprintf(
                "display:inline-block; width:12px; height:12px; background-color:%s; margin-right:5px;",
                m_colors[8]
              )
            ),
            paste("P80:", mpercentiles[9])
          ),
          tags$li(
            tags$span(
              style = sprintf(
                "display:inline-block; width:12px; height:12px; background-color:%s; margin-right:5px;",
                m_colors[9]
              )
            ),
            paste("P90:", mpercentiles[10])
          )
        ),
        
      )
      
    })
    
    
    
    
    
    
    
    output$hist_plot <- renderPlot({
      print("summary hist...")
      
      req(rv_formula_df$dat$val)
      
      hist(
        rv_formula_df$dat$val,
        main = NA,
        xlab = "Distribution of Values",
        ylab = "Frequency",
        col = "grey",
        border = "black"
      )
      
    })
    
    
    #==============================================
    # Stressor Response Table
    #==============================================
    # Initialize with 3 rows as an example.
    sr_values <- reactiveVal(
      data.frame(
        `Raw Stressor Values` = rep("", 3),
        `Stressor-Response Score (0 to 100)` = c("0", "50", "100"),
        `SD` = rep("0", 3),
        `Lower Limit (0 to 100)` = rep("0", 3),
        `Upper Limit (0 to 100)` = rep("100", 3),
        stringsAsFactors = FALSE
      )
    )
    
    output$hot <- renderRHandsontable({
      rhandsontable(sr_values(),
                    rowHeaders = TRUE,
                    stretchH = "all")
    })
    
    
    #------------------------------------------------------------------------
    # renderDygraph charts data visualization
    #------------------------------------------------------------------------
    output$sr_preview_plot <- renderDygraph({
      
      # Get the data table values
      mvals <- sr_values()
      
      return_null_plot <- TRUE
      
      if(nrow(mvals) > 0) {
        
        # Get all SR data
        table_vals <- mvals
        colnames(table_vals) <- c("value", "mean_system_capacity", "sd", "lwr", "upr")
        
        # Replace missing data with appropriate values
        table_vals$value <- as.numeric(as.character(table_vals$value))
        table_vals$mean_system_capacity <- as.numeric(as.character(table_vals$mean_system_capacity))
        table_vals$sd <- as.numeric(as.character(table_vals$sd))
        table_vals$lwr <- as.numeric(as.character(table_vals$lwr))
        table_vals$upr <- as.numeric(as.character(table_vals$upr))
        
        table_vals$lwr_sd <- table_vals$mean_system_capacity - table_vals$sd
        table_vals$upr_sd <- table_vals$mean_system_capacity + table_vals$sd
        
        table_vals$mean_system_capacity <- ifelse(
          is.na(table_vals$mean_system_capacity),
          100,
          table_vals$mean_system_capacity
        )
        
        table_vals$sd <- ifelse(
          is.na(table_vals$sd),
          0,
          table_vals$sd
        )
        
        table_vals$lwr <- ifelse(
          is.na(table_vals$lwr),
          0,
          table_vals$lwr
        )
        
        table_vals$upr <- ifelse(
          is.na(table_vals$upr),
          100,
          table_vals$upr
        )
        
        # Only keep values that are numeric
        table_vals <- table_vals[!is.na(table_vals$value), ]
        
        # Fix lower and upper sd bounds to be within range of limits
        table_vals$lwr_sd <- ifelse(table_vals$lwr_sd < table_vals$lwr, table_vals$lwr, table_vals$lwr_sd)
        table_vals$upr_sd <- ifelse(table_vals$upr_sd > table_vals$upr, table_vals$upr, table_vals$upr_sd)
        
        # Ensure no bad values
        table_vals <- table_vals[, c("value", "mean_system_capacity", "lwr", "upr", "lwr_sd", "upr_sd")]
        
        if(nrow(table_vals) == 0) {
          # No data available to make plot
          return_null_plot <- TRUE
        } else {
          # Data is available to make plot
          return_null_plot <- FALSE
          
          # Make sure data is sorted by value
          table_vals <- table_vals[order(table_vals$value), ]
          
        }
      }
      
      # X-axis mouse-over formatting
      myvFormatter <- "function formatValue(v) {
              var prefix = 'Raw Stressor: ';
              return prefix + String(v);
        }"
      
      # Get additional stressor attributes
      ylab_plot <- "Stressor Response Score (%)"
      
      if(return_null_plot) {
        
        return(NULL)
        
      } else {
        
        # Start and return the dygraph plot
        dygraph(table_vals, main = "Stressor-Response Preview") %>%
          dyAxis("x", label = "Raw Stressor Values", valueFormatter = JS(myvFormatter)) %>%
          dyAxis("y", label = "Response Score") %>%
          dySeries(c("lwr", "mean_system_capacity", "upr"), label = "msc", color = "grey") %>%
          dySeries(c("lwr_sd", "mean_system_capacity", "upr_sd"), label = "Response ", color = "red")
        
      }
      
    })
    
    
    
    
    
    # When the table is edited, update the reactive value.
    observeEvent(input$hot, {
      newData <- hot_to_r(input$hot)
      sr_values(newData)
    })
    
    # Add a new row when requested.
    observeEvent(input$add_row, {
      newData <- sr_values()
      newRow <- data.frame(
        `Raw Stressor Values` = "",
        `Stressor-Response Score (0 to 100)` = "100",
        `SD` = "0",
        `Lower Limit (0 to 100)` = "0",
        `Upper Limit (0 to 100)` = "100",
        stringsAsFactors = FALSE
      )
      sr_values(rbind(newData, newRow))
    })
    
    # Delete the currently selected row (you would need to add logic for selection)
    observeEvent(input$delete_row, {
      # For example purposes, let's delete the last row:
      newData <- sr_values()
      if (nrow(newData) > 0) {
        sr_values(newData[-nrow(newData), , drop = FALSE])
      }
    })
    
    
    #------------------------------------------------------------------------
    # Save data to new SR relationship
    #------------------------------------------------------------------------
    observeEvent(input$save_data, {
      
      print("Save new SR function...")
      
      # Load the new stressor-response relationship data
      # Get the data table values
      mvals <- sr_values()
      
      return_null_plot <- TRUE
      
      if(nrow(mvals) > 0) {
        
        # Get all SR data
        table_vals <- mvals
        colnames(table_vals) <- c("value", "mean_system_capacity", "sd", "lwr", "upr")
        
        # Replace missing data with appropriate values
        table_vals$value <- as.numeric(as.character(table_vals$value))
        table_vals$mean_system_capacity <- as.numeric(as.character(table_vals$mean_system_capacity))
        table_vals$sd <- as.numeric(as.character(table_vals$sd))
        table_vals$lwr <- as.numeric(as.character(table_vals$lwr))
        table_vals$upr <- as.numeric(as.character(table_vals$upr))
        
        table_vals$mean_system_capacity <- ifelse(
          is.na(table_vals$mean_system_capacity),
          100,
          table_vals$mean_system_capacity
        )
        
        table_vals$sd <- ifelse(
          is.na(table_vals$sd),
          0,
          table_vals$sd
        )
        
        table_vals$lwr <- ifelse(
          is.na(table_vals$lwr),
          0,
          table_vals$lwr
        )
        
        table_vals$upr <- ifelse(
          is.na(table_vals$upr),
          100,
          table_vals$upr
        )
        
        # Only keep values that are numeric
        table_vals <- table_vals[!is.na(table_vals$value), ]
        
        if(nrow(table_vals) == 0) {
          # No data available to make plot
          return_null_plot <- TRUE
        } else {
          # Data is available to make plot
          return_null_plot <- FALSE
          
          # Make sure data is sorted by value
          table_vals <- table_vals[order(table_vals$value), ]
          
        }
      }
      
      # Ready to save SR relationship
      if(!(return_null_plot)) {
        
        stressor_name <- input$s_New_Stressor_Name
        stressor_name <- gsub(" ", "_", stressor_name)
        
        # Build new row for main worksheet
        new_row <- data.frame(
          Stressors = stressor_name,
          Stressor_cat = stressor_name,
          Interaction = input$s_Interaction,
          Linked = input$s_Linked,
          Stress_Scale = input$s_Stress_Scale,
          Function = input$s_Function,
          Life_stages = input$s_Life_stages,
          Parameters = input$s_Parameters,
          Units = input$s_Units,
          Model = input$s_Model
        )
        # Replace "NA" with NA
        new_row[new_row == "NA"] <- NA
        new_row[new_row == ""] <- NA
        new_row[is.na(new_row)] <- "NA"
        
        
        print("flush out old data...")
        
        # Update refresh time
        session$userData$rv_stressor_response$active_refresh <- Sys.time()
        
        # Gather input for main worksheet
        session$userData$rv_stressor_response$main_sheet <- rbind(session$userData$rv_stressor_response$main_sheet, new_row = new_row)
        
        # Add stressor name
        session$userData$rv_stressor_response$stressor_names <- c(session$userData$rv_stressor_response$stressor_names, stressor_name)
        
        # Add pretty name
        session$userData$rv_stressor_response$pretty_names <- c(session$userData$rv_stressor_response$stressor_names, gsub("_", " ", stressor_name))
        
        # Add the SR data table - make sure it is added as a tibble
        session$userData$rv_stressor_response$sr_dat[[stressor_name]] <- dplyr::tibble(table_vals[, c("value", "mean_system_capacity", "sd", "lwr", "upr")])
        
        # Add on data to stressor-magnitude table
        bnsm <- rv_formula_df$dat
        bnsm$Stressor <- stressor_name 
        bnsm$Stressor_cat <- stressor_name 
        bnsm$Mean <- bnsm$val 
        bnsm$SD <- 0 
        bnsm$Distribution <- "normal" 
        bnsm$Low_Limit <- min(bnsm$val, na.rm = TRUE) 
        bnsm$Up_Limit <- max(bnsm$val, na.rm = TRUE) 
        bnsm$Comments <- NA
        bnsm <- bnsm[, colnames(session$userData$rv_stressor_magnitude$sm_dat)]
        
        # Merge onto master sm data
        session$userData$rv_stressor_magnitude$sm_dat <- rbind(
          session$userData$rv_stressor_magnitude$sm_dat,
          bnsm
        )
        
        # End of data addition....
      }
      
      
      # When the button is pressed, render a green success message
        showNotification("New Stressor and Stressor-Response relationship was created!", 
                         type = "default", 
                         duration = 5)  # The message will disappear after 3 seconds
      
    })
    
    
    
    
  })
}
