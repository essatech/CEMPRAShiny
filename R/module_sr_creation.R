# ===========================================
# Custom Stressor-response creation function
# ===========================================

module_sr_creation_ui <- function(id) {
  ns <- NS(id)
  
  tagList(shinydashboard::box(width = 12, fluidRow(
    column(
      width = 12,
      
      tags$h3(
        "Formula Builder: Create Novel Stressors and Stressor-Response Relationships"
      ),
      
      tags$p(
        "The ‘Custom Stressor Creation’ module, within the ‘Special Features’ tab, can be used to develop novel stressors from existing data using a formula builder. The formula builder takes in existing variables, including existing stressors, and provides the option to add them into a custom formula expression input box to generate new variables. This module can be creatively leveraged for a myriad of applications. For example, the interaction between two stressors can be expressed and modelled as a new unique metrics, existing stressors can be re-computed for simple scenarios (e.g., adding 2 degrees to represent future climate change, or multiplying a land-use stressor by 0.8). The ‘Custom Stressor Creation’ module can also be used for more advanced applications such as applying preexisting regression equations to develop new stressors from specific input datasets where prior research has already developed detailed SR functions that are not expressed as simple univariate relationships.",
        style = "text-align: justify;",
        class = "pm-ht"
      ),
      
      tags$p(
        "There are several steps in the ‘Custom Stressor Creation’ module. First, a user adds selected variables (as stressors) into a formula builder input text box. Various mathematical expressions (e.g., addition, subtraction, multiplication, division, exponents, brackets, log, log10 etc.) can be used to customize the formula. Next, the user clicks the ‘Run Formula and Generate New Data’ button to apply the equation to all unique locations. A new temporary variable is generated and stored for each location that consists of the numerical result of the custom formula. The user carefully reviews the result of the equation to make an informed decision whether the new variable should be added to the model as a novel stressor. A stressor-response relationship is assigned to the new raw stressor values (either by copying values from a pre-existing stressor-response curve or developing a new custom stressor-response curve). Finally, the values are saved and added to the primary stressor magnitude and stressor-response datasets for use in the Joe Model and/or Population Model. Note that if the custom formula is treated as a stand-alone stressor response function, then the new raw stressor values generated by the function can be treated directly as the predicted habitat or system capacity, rather than treated as a stressor to which a stressor-response function is applied.  Alternatively, an identity stressor-response function (straight line with a slope of 1) can be chosen as the new custom stressor-response curve to treat the formula output as a direct metric of habitat capacity.",
        style = "text-align: justify;",
        class = "pm-ht"
      ),
      
      
      # Create Bootstrap Pills of possible terms
      tags$b("Possible Formula Terms (raw stressor variables):"),
      
      tags$p(
        "Alpine_Cover_pct, Drainage_Area_km2, Drainage_Density_km_km2, Glacier_Cover_pct, July_Temp, Lake_Cover_pct, Lake_Influence_pct, MAP_mm, MAT, Median_Elev_m, Min_Elev_m, Reach_Gradient_pct, Reach_Length_km, Relief_m, Stream_Magnitude, Stream_Order, Terrain_Slope_pct, Total_Stream_Length_km ",
        style = "color: purple;"
      ),
      
      tags$br(),
      
      
      
      
      
    )
  ), fluidRow(
    column(
      width = 9,
      
      fluidRow(column(
        width = 12,
        
        shinydashboard::box(
          width = 12,
          #style = "background-color: #dfebe8;",
          
          # '#dfebe8','#ffffb3','#dddaed','#ffd8d4'
          
          tags$h4("Step 1: Create a New Stressor with the Formula Builder"),
          
          tags$p(
            "Create a new stressor by entering a custom formula in the formula expression input textbox. Various mathmetrical expressions can be used such as addition (+), subtraction (-), multiplication (*), division (/), exponents(x^y), brackets((x)), log (e.g., log(x)), sqrt (e.g., sqrt(x)), log10 etc. Be careful to ensure that your formula is valid (e.g., has matching closing brackets). The only variables that can be used are the names of preexisting stressors in the stressor magnitude input workbook. Make sure the spelling is exact. Add custom metrics to the stressor magnitude data as needed. You do not need to define a stressor-response relationship for various habitat metrics that may exist only in the stressor-magnitude workbook. The following examples provide some sample formulas to help develop an understanding of the format and possibilities:",
            style = "text-align: justify;",
            class = "pm-ht"
          ),
          
          
          HTML(
            '
    <ul class = "pm-ht">
      <li>e.g., apply a simple fixed increase or decrease in the raw value of a stressor (e.g., fines):
        <ul>
          <li>Fines_pct*0.8</li>
          <li>Fines_pct-10</li>
        </ul>
      </li>
      <li>e.g., define a possible interactive effect between stream temperature and peak flows (example from Wenger et al., 2011: PNAS):
        <ul>
          <li>(-0.59*Temp)+((-0.88*Temp)^2)+(-0.20*PeakFlows)</li>
        </ul>
      </li>
      <li>e.g., apply a custom regression equation to roughly predict MWAT (Maximum Weekly Average Stream Temperature) from basin-level GIS variables (Moore et al., 2013: Canadian Water Resources Journal):
        <ul>
          <li>7.91+(0.484*July_Temp)+(1.18*log10(Drainage_Area_km2+0.000001))+(-0.00306*Median_Elev_m)+(17.5*sqrt(Lake_Cover_pct/100))+(-9.43*sqrt(Glacier_Cover_pct/100))+(0.0529*(Reach_Gradient_pct/100))-(0.719*0.25)</li>
        </ul>
      </li>
    </ul>'
          ),
          
          # Text area for formula input
          textAreaInput(
            ns("formula"),
            label = "Enter Formula Expression Here:",
            value = "",
            rows = 3,
            placeholder = "Enter your formula here..."
          ),
          # Optional: UI to insert allowed variable names from the dataframe
          uiOutput(ns("var_buttons")),
          
          # Button to evaluate the formula
          actionButton(
            ns("eval_formula"),
            "Run Formula and Generate New Data",
            icon = icon("play"),
            class = "btn btn-success",
            style = "color: white;"
          ),
          # Output: Show result of evaluating the formula on the dataframe
          verbatimTextOutput(ns("formula_result"))
          
          
          
        ),
        
        
        
        
        
        
      )),
      
      tags$hr(),
      
      
      
      # create box
      shinydashboard::box(
        width = 12,
        #style = "background-color: #f7f7e6;",
        
        tags$h4("Step 2: Evaluate Stressor Values"),
        
        tags$p(
          "After the ‘Run Formula and Generate New Data’ button is pushed the new stressor values are temporarily cached for review. Summary statistics are shown on the right side of the display and an interactive choropleth map interface is included below. Reviewing values in these sections is useful to identify possible errors and issues. The formula can be edited and rerun. Each time the ‘Run Formula and Generate New Data’ button is pushed the stressor data is overwritten",
          class = "pm-ht"
        ),
        
        fluidRow(column(
          width = 12,
          # Mouse-over text for basin name and HUC code
          htmlOutput(ns("txt_basin_name")),
          htmlOutput(ns("txt_huc_code")),
          
          # Main leaflet output with variable width and fixed height
          leafletOutput(ns("srcmap"), height = 550),
        ))
        
        
        
      ),
      
      
      
      
      
      tags$p(
        "Evaluate results carefully before moving on to the next section.",
        class = "pm-ht"
      ),
      
      
      
      tags$br(),
      
      fluidRow(
        shinydashboard::box(
          width = 12,
          #style = "background-color: #dddaed;",
          
          # '#dfebe8','#ffffb3','#dddaed','#ffd8d4'
          
          tags$h4("Step 3: Define or Develop Stressor-Response Data"),
          
          tags$p(
            "In Step 3 users assign or develop a stressor-response relationship to be associated with the newly created stressor metric. Users may either copy an existing stressor-response relationship or create a new relationship from scratch. Copying an existing relationship can be useful if the newly created stressor represents a scenario or variant of a pre-existing stressor. Creating a new stressor-response relationship can be useful if the newly created stressor requires an entirely new relationship.",
            class = "small-helper-text"
          ),
          
          
          
          # create a radio select button for create new SR relationship or copy existing
          radioButtons(
            ns("sr_radio"),
            "Create New or Copy Existing Stressor-Response Relationship:",
            c(
              "Create New Stressor-Response Relationship" = "new",
              "Copy Existing Stressor-Response Relationship" = "copy"
            ),
            selected = "new"
          ),
          
          
          tags$p(
            "If a novel stressor-response relationship is being created from scratch, use the following inputs to define how the stressor is linked to the focal species/system. The stressor-response relationship table will also need to be populated. Rows can be added or removed to adjust the complexity of the relationship.",
            class = "small-helper-text"
          ),
          
          
          fluidRow(
            column(
              width = 3,
              selectInput(
                ns("s_Interaction"),
                "Interactions:",
                c(
                  "NA" = NA,
                  "Minimum" = "Minimum",
                  "Maximum" = "Maximum"
                )
              ),
              bsTooltip(
                id = ns("s_Interaction"),
                title = "Choose whether to use the minimum or maximum interaction rule",
                placement = "top",
                trigger = "hover"
              ),
              
              class = "grouped-box-1"
            ),
            column(
              width = 3,
              selectInput(
                ns("s_Linked"),
                "Interaction (Linked) Groups:",
                c(
                  "NA" = NA,
                  "A" = "A",
                  "B" = "B",
                  "C" = "C",
                  "D" = "D",
                  "E" = "E"
                )
              ),
              class = "grouped-box-1"
            ),
            
            column(
              width = 3,
              selectInput(
                ns("s_Function"),
                "Function Type:",
                c("continuous" = "continuous", "step" = "step")
              ),
              class = "grouped-box-2"
            ),
            
            column(
              width = 3,
              selectInput(
                ns("s_Stress_Scale"),
                "Raw Stressor Scale:",
                c("linear" = "linear", "log" = "log")
              ),
              class = "grouped-box-2"
            )
          ),
          
          fluidRow(
            column(
              width = 3,
              selectInput(
                ns("s_Model"),
                "Model Endpoint:",
                c(
                  "All" = "All",
                  "Joe Model" = "Joe Model",
                  "Population Model" = "Population Model"
                )
              ),
              class = "grouped-box-4"
            ),
            column(
              width = 3,
              selectInput(
                ns("s_Life_stages"),
                "Life Stages (Pop. Only):",
                c("..." = "...", "other..." = "other...")
              ),
              class = "grouped-box-3"
            ),
            column(
              width = 3,
              selectInput(
                ns("s_Parameters"),
                "Vital Rate Parameters (Pop. Only):",
                c(
                  "survival" = "survival",
                  "capacity" = "capacity",
                  "fecundity" = "fecundity"
                )
              ),
              class = "grouped-box-3"
            ),
            column(
              width = 3,
              textInput(ns("s_Units"), "Raw Stressor Units:", value = "units"),
              class = "grouped-box-4"
            )
          ),
          
          tags$br(),
          
          
          tags$b("Build the Stressor-Response Relationship"),
          
          tags$p(
            "Populate the following table with the raw stessor values (e.g., stream temperature in degrees), the stressor-response relationship score for each level (scaled from 0 to 100%), the standard deviation (SD) of the response for each part of the relationship (in percent), and the lower and upper limits of the response score (both scale from 0% to 100%).",
            class = "small-helper-text"
          ),
          
          
          
          # create a static html table with three rows and columns for 'Raw Stressor Value', 'Stressor-Response Score', 'SD', 'Lower Limit', 'Upper Limit'
          tags$table(
            class = "table",
            tags$tr(
              tags$th("Raw Stressor Value"),
              tags$th("Stressor-Response Score"),
              tags$th("SD"),
              tags$th("Lower Limit"),
              tags$th("Upper Limit"),
              tags$th("Delete Row")
            ),
            tags$tr(
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td(actionLink(ns("delete_row"), "Delete Row"))
            ),
            tags$tr(
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td(actionLink(ns("delete_row"), "Delete Row"))
            ),
            tags$tr(
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td(actionLink(ns("delete_row"), "Delete Row"))
            ),
            tags$tr(
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td("", style = "border: 1px solid;"),
              tags$td(actionLink(ns("delete_row"), "Delete Row"))
            ),
          ),
          
          # create button to add new row
          actionButton(ns("s_Add_Row"), "Add Row"),
          
          
          # create a static html table with three rows and columns for 'Raw Stressor Value', 'Stressor-Response Score', 'SD', 'Lower Limit', 'Upper Limit'
          
          
          
          
        )
      ),
      
      tags$br(),
      
      
      
      fluidRow(
        shinydashboard::box(
          width = 12,
          #style = "background-color: #ffd8d4;",
          
          # '#dfebe8','#ffffb3','#dddaed','#ffd8d4'
          
          tags$h4(
            "Step 4: Add New Stressor and Stressor-Response Relationship to Model"
          ),
          
          tags$p(
            "Finally, in Step 4, we take our newly created stressor and stressor-response relationship and add it to the stressor-magnitude and stressor-response datasets for use in the Joe and Population Model, as well as other components of the tool. After the ‘Add Stressor and Stressor-Response Relationship to Model’ button is pressed the entire application will update itself to include the newly created stressor. It is important to assign a clear and unique name to the new stressor. Do not use spaces or special characters.",
            class = "pm-ht"
          ),
          
          # Create an input text box for the user to enter a name for the new stressor
          textInput(ns("s_New_Stressor_Name"), "NewStressor Name:", value = "New_Stressor"),
          
          # create a green submit button
          actionButton(
            ns("save_data"),
            "Add Stressor and Stressor-Response Relationship to Model",
            class = "btn btn-success",
            icon = icon("save"),
            style = "color: white;"
          )
          
          
        )
      ),
      
      
      
    ),
    column(
      width = 3,
      style = "padding-left: 0; margin-left: -10px;",
      shinydashboard::box(width = 12, 
                          #style = "background-color: #f7f7e6;",
                          fluidRow(
        column(
          width = 12,
          
          tags$br(),
          tags$b("Summary Statistics For New Stressor:"),
          tags$p("Min: 10.4"),
          tags$p("Max: 22.4"),
          tags$p("Mean: 15.8"),
          tags$p("Median: 16.0"),
          tags$p("SD: 3.3"),
          tags$br(),
          
          tags$b("Percentile Breakpoints:"),
          tags$p("P10: 11.2"),
          tags$p("P20: 12.5"),
          tags$p("P30: 13.4"),
          tags$p("P40: 15.0"),
          tags$p("P50: 16.0"),
          tags$p("P60: 17.0"),
          tags$p("P70: 17.6"),
          tags$p("P80: 18.9"),
          tags$p("P90: 20.1"),
          
          tags$br(),
          tags$b("Raw Distribution of Stressor Values:"),
          
          # plot output
          plotOutput(ns("hist_plot"))
          
          
        )
      ), ),
    ),
  )))
}


# ==========================
# SERVER FUNCTION
# ==========================

module_sr_creation_server <- function(id, df, allowed_vars = NULL) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    # If a list of allowed variable names is provided, create a small insert widget.
    output$var_buttons <- renderUI({
      if (is.null(allowed_vars))
        return(NULL)
      tagList(
        selectInput(ns("var_select"), "Insert Variable:", choices = allowed_vars),
        actionButton(ns("insert_var"), "Insert")
      )
    })
    
    # When the "Insert" button is clicked, append the selected variable name to the formula.
    observeEvent(input$insert_var, {
      var_to_insert <- input$var_select
      new_formula <- paste0(input$formula, " ", var_to_insert)
      updateTextAreaInput(session, "formula", value = new_formula)
    })
    
    
    # A basic sanitization function that allows only common arithmetic characters,
    # letters, digits, whitespace, period, comma, and underscore.
    sanitize_formula <- function(formula_str) {
      # Allow letters, digits, whitespace, and these symbols: + - * / ^ ( ) . , _
      if (grepl("[^0-9a-zA-Z\\+\\-\\*/\\^\\(\\)\\.\\s,_]",
                formula_str)) {
        return(NULL)
      }
      return(formula_str)
    }
    
    # When "Evaluate Formula" is clicked, parse and evaluate the expression
    observeEvent(input$eval_formula, {
      formula_str <- input$formula
      safe_formula <- sanitize_formula(formula_str)
      if (is.null(safe_formula)) {
        output$formula_result <- renderText("Error: Formula contains invalid characters!")
        return()
      }
      
      # Try to parse and evaluate the expression.
      # We evaluate in the environment of the provided dataframe `df`.
      result <- tryCatch({
        expr <- parse(text = safe_formula)
        # Because the columns in df are vectorized, the expression is computed for every row.
        eval(expr, envir = df)
      }, error = function(e) {
        paste("Error in evaluating formula:", e$message)
      })
      
      output$formula_result <- renderPrint(result)
    })
    
    # --------------------------------------
    # Main leaflet map reactive expression
    # --------------------------------------
    # Main leaflet map is called here, but only static elements
    # are included that do not need updating with dynamic events.
    # HUCs are called later with proxy since we will update then frequently.
    output$srcmap <- renderLeaflet({
      print("Running renderLeaflet()...")
      mymap <- leaflet() %>%
        addProviderTiles(
          providers$Esri.WorldTopoMap,
          group = "Topo",
          options = providerTileOptions(noWrap = TRUE, opacity = 0.9)
        ) %>%
        addProviderTiles(providers$Esri.WorldImagery, group = "Imagery") %>%
        addProviderTiles(
          providers$Esri.WorldGrayCanvas,
          group = "Grey",
          options = providerTileOptions(noWrap = TRUE, opacity = 0.9)
        ) %>%
        addLayersControl(
          baseGroups = c("Topo", "Imagery", "Grey"),
          options = layersControlOptions(collapsed = FALSE)
        )
      
      if (isolate(session$userData$geom_type) == "lines") {
        line_weight <- 3
        if (!(is.null(
          isolate(session$userData$rv_HUC_layer_load$data$WIDTH)
        ))) {
          line_weight <- isolate(session$userData$rv_HUC_layer_load$data$WIDTH)
        }
        mymap <- addPolylines(
          map = mymap,
          data = session$userData$rv_HUC_layer_load$data,
          layerId = session$userData$rv_HUC_layer_load$data$uid,
          color = "#3b9ab2",
          weight = line_weight,
          smoothFactor = 0.5,
          opacity = 0.7,
          highlightOptions = highlightOptions(
            color = "#c2fffe",
            weight = 4,
            bringToFront = TRUE
          )
        )
      } else {
        mymap <- addPolygons(
          map = mymap,
          data = session$userData$rv_HUC_layer_load$data,
          layerId = session$userData$rv_HUC_layer_load$data$uid,
          color = "#444444",
          weight = 1.2,
          smoothFactor = 0.5,
          opacity = 0.5,
          fillOpacity = 0.5,
          fillColor = "#d9d9d9",
          highlightOptions = highlightOptions(
            color = "white",
            weight = 2,
            bringToFront = TRUE
          )
        )
      }
      
      mymap
      # fitBounds(-119.04060, 52.37167, -114.78314, 54.76054)
    })
    
    
    # ---------------------------------------------------------
    # Reactive expression to reload, repaint or redraw polygons
    # ---------------------------------------------------------
    r_huc_polygons <- reactive({
      print("r_huc_polygons() triggered ...")
      
      # If clear all selected - then trigger redraw.
      session$userData$rv_redraw$redraw
      
      # Name of the variable to display
      var_name <-
        session$userData$rv_stressor_response$active_layer
      
      # HUC spatial geometry
      huc_geom <- session$userData$rv_HUC_geom$huc_geom
      
      # Check if geometry is line or polygon
      geom_type <-
        st_geometry_type(session$userData$rv_HUC_layer_load$data)
      if (unique(geom_type)[1] %in% c("LINESTRING", "MULTILINESTRING")) {
        session$userData$geom_type <- "lines"
      } else {
        session$userData$geom_type <- "polygons"
      }
      
      # Get values from magnitude table if normal variable
      if (var_name != "system_capacity") {
        # Data for HUCs (Stressor Magnitude)
        sm_df <- session$userData$rv_stressor_magnitude$sm_dat
        sm_df <- sm_df[sm_df$Stressor == var_name, ]
        
        # Merge stressor magnitude values to sf object
        huc_geom$values <- NA
        huc_geom$values <-
          sm_df$Mean[match(huc_geom$HUC_ID, sm_df$HUC_ID)]
        
        # Look at relationship from response curve
        resp_curv <-
          session$userData$rv_stressor_response$sr_dat[[var_name]]
        
        if (is.null(resp_curv)) {
          # Special case for interaction matrix
          print("Interaction matrix...")
          sm_df <- session$userData$rv_stressor_magnitude$sm_dat
          MInt_all <-
            session$userData$rv_stressor_response$interaction_values
          MInt <- MInt_all[[var_name]]
          sm_df$dose <- sm_df$Mean
          sm_df$HUC <- sm_df$HUC_ID
          sm_df$simulation <- 1
          sm_df$sys.cap <- NA
          sm_df <-
            sm_df[, c("HUC", "Stressor", "simulation", "dose", "sys.cap")]
          sys_cap_resp <-
            CEMPRA::interaction_matrix_sys_cap(
              MInt = MInt,
              sc.dose.df = sm_df,
              adult_sys_cap = FALSE
            )
          sys_cap_resp <-
            sys_cap_resp[which(sys_cap_resp$Stressor == var_name), ]
          
          # Assign values to HUC
          huc_geom$values <-
            sys_cap_resp$sys.cap[match(huc_geom$HUC_ID, sys_cap_resp$HUC)]
          huc_geom$values_sc <- huc_geom$values
          
          # Convert to percent for matrix surface
          huc_geom$values_sc <- huc_geom$values_sc * 100
          
        } else {
          # Normal stressor interpolation using curve
          # Convert raw variable values to system capacity
          
          interp <- approx(
            x = resp_curv$value,
            y = resp_curv$mean_system_capacity,
            xout = huc_geom$values,
            rule = 2 # MJB change: points outside of range assume closest
            # yleft = 0, yright = 100
          )
          huc_geom$values_sc <- interp$y
        }
        
      } else {
        # Otherwise look at system capacity from Joe mode
        res <- session$userData$rv_joe_model_results$sims
        res <-
          res[[length(res)]] # Get the latest result (if multiple)
        # Take the average by each watershed
        df_vals <- res$ce.df %>%
          dplyr::group_by(HUC) %>%
          dplyr::summarise(values_sc = mean(CE))
        # Add values as attribute to original object
        huc_geom$values_sc <-
          df_vals$values_sc[match(huc_geom$HUC_ID, df_vals$HUC)]
        huc_geom$values_sc <- huc_geom$values_sc * 100
        
      }
      
      # Apply color ramp function
      huc_geom$color_vec <- color_func(huc_geom$values_sc)
      
      # Update reference color dataframe rv to reset colors after selection
      col_df <-
        data.frame(id = huc_geom$HUC_ID, col = huc_geom$color_vec)
      session$userData$rv_HUC_geom$color_df <- col_df
      
      return(huc_geom)
    })
    
    
    # --------------------------------------
    # HUC polygon draw
    # --------------------------------------
    # Draw update or edit HUC polygons on leaflet map
    # use an observe() function to capture changes and use
    # leafletProxy() to only update the target layer.
    
    print("HUC polygon draw...")
    
    observe({
      print("Updating polygons with observer()...")
      
      if (isolate(session$userData$geom_type) == "lines") {
        line_weight <- 3
        if (!(is.null(
          isolate(session$userData$rv_HUC_layer_load$data$WIDTH)
        ))) {
          line_weight <- isolate(session$userData$rv_HUC_layer_load$data$WIDTH)
        }
        leafletProxy("srcmap") %>%
          clearShapes() %>%
          # Add or update HUC polygons on the map
          addPolylines(
            data = r_huc_polygons(),
            layerId = r_huc_polygons()$uid,
            color = r_huc_polygons()$color_vec,
            weight = line_weight,
            smoothFactor = 0.5,
            opacity = 0.7,
            highlightOptions = highlightOptions(
              color = "#c2fffe",
              weight = 4,
              bringToFront = TRUE
            )
          ) %>%
          # Delete any old pre-existing legend
          clearControls() %>%
          # Add new legend
          addLegend(
            "bottomright",
            colors = leg_col,
            labels = leg_lab,
            title = session$userData$rv_stressor_response$active_layer,
            opacity = 0.9
          )
      }
      if (session$userData$geom_type == "polygons") {
        leafletProxy("srcmap") %>%
          clearShapes() %>%
          # Add or update HUC polygons on the map
          addPolygons(
            data = r_huc_polygons(),
            layerId = r_huc_polygons()$uid,
            color = "#444444",
            weight = 1.2,
            smoothFactor = 0.5,
            opacity = 0.5,
            fillOpacity = 0.5,
            fillColor = r_huc_polygons()$color_vec,
            highlightOptions = highlightOptions(
              color = "white",
              weight = 2,
              bringToFront = TRUE
            )
          ) %>%
          # Delete any old pre-existing legend
          clearControls() %>%
          # Add new legend
          addLegend(
            "bottomright",
            colors = leg_col,
            labels = leg_lab,
            title = session$userData$rv_stressor_response$active_layer,
            opacity = 0.9
          )
      }
      
      
      
      
      # Add on selected HUCs (if any)
      selected_hucs <- isolate(session$userData$rv_clickedIds$ids)
      
      if (length(selected_hucs) > 0) {
        print("Adding selected HUCs")
        huc_geom_sel <- session$userData$rv_HUC_geom$huc_geom
        
        # Get subset of selected HUCs
        huc_geom_sel <-
          huc_geom_sel[which(huc_geom_sel$uid %in% selected_hucs), ]
        
        # Update special ID
        huc_geom_sel$uid <- paste0("select|", huc_geom_sel$uid)
        
        # Add selected HUCs to map
        if (session$userData$geom_type == "lines") {
          line_weight <- 3
          if (!(is.null(
            isolate(session$userData$rv_HUC_layer_load$data$WIDTH)
          ))) {
            line_weight <- isolate(session$userData$rv_HUC_layer_load$data$WIDTH)
          }
          leafletProxy("srcmap") %>%
            addPolylines(
              data = huc_geom_sel,
              layerId = huc_geom_sel$uid,
              color = "#4dfff3",
              weight = line_weight,
              smoothFactor = 0.5,
              opacity = 0.9,
              #fillOpacity = 0.95,
              #fillColor = "#4dfff3",
              highlightOptions = highlightOptions(
                color = "#c2fffe",
                weight = 4,
                bringToFront = TRUE
              )
            )
        }
        
        if (session$userData$geom_type == "polygons") {
          leafletProxy("srcmap") %>%
            addPolygons(
              data = huc_geom_sel,
              layerId = huc_geom_sel$uid,
              color = "#c2fffe",
              weight = 1.2,
              smoothFactor = 0.5,
              opacity = 0.9,
              fillOpacity = 0.95,
              fillColor = "#4dfff3",
              highlightOptions = highlightOptions(
                color = "white",
                weight = 2,
                bringToFront = TRUE
              )
            )
        }
        
        
      }
    })
    
    
    
    # ---------------------------------------------------------
    # Define the stressor variables to plot div button side bar
    # ---------------------------------------------------------
    output$stressor_variable_list <- renderUI({
      print("Re-populating stressor variables...")
      snames <-
        session$userData$rv_stressor_response$stressor_names
      pnames <- session$userData$rv_stressor_response$pretty_names
      svar_list <- list()
      
      # Check if there are any matrix interaction variables
      var_id <- 1
      
      # Call sub modules
      for (s in 1:length(snames)) {
        this_stressor <- snames[s]
        print(this_stressor)
        svar_list[[s]] <-
          module_stressor_variable_ui(ns(this_stressor))
        
        module_stressor_variable_server(this_stressor, stressor_index = s)
        var_id <-
          var_id + 1 # Use this index for the matrix interactions (if any)
      }
      
      # Call sub modules to create matrix button
      mnames <-
        session$userData$rv_stressor_response$interaction_names
      if (!(is.null(mnames))) {
        for (m in 1:length(mnames)) {
          this_interaction <- mnames[m]
          print("Rendering matrix interaction...")
          print(this_interaction)
          svar_list[[var_id]] <-
            module_stressor_variable_ui(ns(this_interaction))
          module_stressor_variable_server(this_interaction, stressor_index = var_id)
          var_id <- var_id + 1
        }
      }
      
      return(svar_list)
    })
    
    
    
    # ---------------------------------------------------------
    # Show the HUC Code and Basin Name Above Map
    # ---------------------------------------------------------
    output$txt_huc_code <- renderUI({
      if (session$userData$rv_map_shape()) {
        tags$p(session$userData$rv_map_location$huc_id, style = "float: right; color:#3b9ab2;")
      } else {
        tags$p("Location ID", style = "float: right; color:#3b9ab2;")
      }
    })
    
    output$txt_basin_name <- renderUI({
      if (session$userData$rv_map_shape()) {
        tags$p(session$userData$rv_map_location$huc_name, style = "float: left; color:#3b9ab2;")
      } else {
        tags$p("Location Name", style = "float: left; color:#3b9ab2;")
      }
    })
    
    
    # ---------------------------------------------------------
    # Mouse-over and mouse-out events
    # ---------------------------------------------------------
    # Observe mouseover events over leaflet map
    # note the event concatenation 'object name' + '_click'; 'object name' + '_shape_mouseover'
    observeEvent(input$srcmap_shape_mouseout, {
      session$userData$rv_map_shape(FALSE)
      session$userData$rv_stressor_response$active_values_raw <-
        NULL
    })
    
    observeEvent(input$srcmap_shape_mouseover, {
      # User hovers mouse over a polygon (layer specific)
      srcmap_shape_mouseover_info <-
        input$srcmap_shape_mouseover
      
      if (!(is.null(srcmap_shape_mouseover_info))) {
        # Parse the ID and HUC name
        session$userData$rv_map_shape(TRUE)
        poly_obj <-
          srcmap_shape_mouseover_info$id # note leaflet id slot
        parse_id <- strsplit(as.character(poly_obj), "\\|")[[1]]
        huc_id <- parse_id[1]
        huc_name <- parse_id[2]
        session$userData$rv_map_location$huc_id <- huc_id
        session$userData$rv_map_location$huc_name <- huc_name
        session$userData$rv_stressor_response$active_values_raw <- NULL
        
      }
    })
    
    
    # ------------------------------------------
    # Update selected class on layer panel
    observe({
      req(input$hiddenload)
      req(session$userData$rv_stressor_response$active_layer)
      print("Setting style...")
      # print(active)
      # Strip class away from any other selected
      # q_code <- paste0("jQuery('.map-variable').removeClass('var-selected');")
      # shinyjs::runjs(code = q_code)
      
      # Add class to system capacity
      #  q_code <- paste0("jQuery('#main_map-var_id').addClass('var-selected');")
      # shinyjs::runjs(code = q_code)
    })
    
    
    
    output$hist_plot <- renderPlot({
      hist(
        junk_hist$MWAT,
        main = NA,
        xlab = "Raw Stressor Values",
        ylab = "Frequency",
        col = "grey",
        border = "black"
      )
      
      
      
    })
    
    
  })
}
